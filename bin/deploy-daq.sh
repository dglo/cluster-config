#!/bin/sh

# A script for creating a set of .ear files for un/deploying DAQ-PROD
# to a cluster.

# This script assumes you have already built the cluster-config
# project and have an ssh-agent running with a private key loaded that
# the remote jboss account on all the target machines trusts.

# Save the location of this script and the dir this script is
# being executed from.  Used for locating other needed files.
SCRIPT=`basename $0`
SCRIPT_DIR=`dirname $0`
START_DIR=`pwd`
FULL_DIR=${START_DIR}/${SCRIPT_DIR}
WS_DIR=`cd ${FULL_DIR}/../..; pwd`
BUILD_DIR=${WS_DIR}/build/cluster-config

# Action: build (-b), deploy (-d) or undeploy (-u).
ACTION=none
SAR_TARGET=bin
EAR_TARGET=nodeps.ws.ear

# Parse command line args
while getopts :bduentqakr:c:h FLAG; do
  case "${FLAG}" in
    h|\?) echo "Build, deploy or undelpoy DAQ-PROD for the current cluster."
       echo "Usage: ${SCRIPT} -b|-d|-u [-e] [-n] [-t] [-q] [-a] [-k] [-r srvc] [-c cmd] [-h]"
       echo " One of the following 3 flags must be present (last one prevails):"
       echo "  -b      -> Build .sar files only (needs to be done before deploying)."
       echo "  -d      -> Deploy .ear files into cluster."
       echo "  -u      -> Undeploy .ear file from cluster."
       echo " Optional flags:"
       echo "  -e      -> EJB: deploy or undeploy ejbs (the db node) only."
       echo "  -n      -> No exec: print but don't execute, commands (implies -t)."
       echo "  -t      -> Trace: print commands as they are run by this script."
       echo "  -q      -> Quiet: Pass the '-q' flag to ant to be quiet (you want this)."
       echo "  -a      -> Ant: run \`ant clean.ws lib.all\` from top of Workspace first (implies -b, ignored by -u)."
       echo "  -k      -> Keep going, if a command fails."
       echo "  -r srvc -> Rebuild only srvc.sar.  This flag may be repeated to rebuild only"
       echo "             a targeted set of .sar files into the .ear files."
       echo "  -c cmd  -> Only send "cmd" to each node via 'ssh <node> \"cmd\"'"
       echo "  -h      -> Help: display this usage message and exit."
       echo
       echo "Examples:"
       echo "  Build all the sar files, tracing commands and making ant quiet:"
       echo "    $ ${SCRIPT} -btq"
       echo "  Deploy EJBs, tracing commands and making ant quiet (pointless on a merc):"
       echo "    $ ${SCRIPT} -detq"
       echo "  Deploy the rest of the services, tracing & being quiet:"
       echo "    $ ${SCRIPT} -dtq"
       echo "  Undeploy, tracing & quiet:"
       echo "    $ ${SCRIPT} -utq"
       echo "  Undeploy EJBs, tracing & quiet:"
       echo "    $ ${SCRIPT} -uetq"
       echo "  Trace, quiet deploy, but rebuild only stringProcessor-0.sar:"
       echo "    $ ${SCRIPT} -tqr stringProcessor-0"
       echo "  Trace, quiet deploy, rebuild only stringProcessor-0.sar & iniceTrigger.sar:"
       echo "    $ ${SCRIPT} -tqr iniceTrigger -r stringProcessor-0"
       exit 0
       ;;
    b) ACTION=build
       ;;
    d) ACTION=deploy
       ;;
    u) ACTION=undeploy
       ;;
    e) EJBS=on
       ;;
    n) NOT_REALLY=on
       TRACE=on
       ;;
    t) TRACE=on
       ;;
    q) ANT_FLAGS=-q
       ;;
    a) COMPILE=on
       ;;
    k) KEEP_GOING=on
       ;;
    r) CUST_SRVC="${CUST_SRVC} ${OPTARG}"
       ;;
    c) COMMAND=${OPTARG}
       ACTION=command
       ;;
  esac	
done

# This is for debug/tracing this script and exiting up command failure
runComm () {
  test "${TRACE}" && echo $1
  test "${NOT_REALLY}" || eval $1 || test "${KEEP_GOING}" || exit 1
}

# Where the below ant commands need to be run from
runComm "cd ${WS_DIR}"

# Run 'ant clean.ws lib.all' if requested
test "$COMPILE" && test "$ACTION" != "undeploy" && runComm "ant ${ANT_FLAGS} clean.ws lib.all"

# Check for existance of the deployment dir
if [ ! -d ${BUILD_DIR} ]; then
  echo "The cluster-config build dir: ${BUILD_DIR}"
  echo "either doesn't exist or isn't a directory."
  echo "This script depends on files in that dir to be generated by"
  echo "building the cluster-config project."
  exit 1
fi

# Pick up CLUSTER, DB_NODES & NODES definition (this doesn't go
# through runComm since it needs to happen for the -n flag to work
# properly).
. ${BUILD_DIR}/daq-node-list

# Set the list of nodes to actually deploy to in this invocation.
# This is used in constucting the names of the .ear files.  This is
# changed by the -e flag, except in the case of a merc "cluster" where
# that flag is ignored.
DEPLOY_NODES=${NODES}
if [ "${EJBS}" = "on" ]; then
  DEPLOY_NODES=${DB_NODES}
fi

# Pick up SP_MAP definition, used to decide from which project each
# service is built (this doesn't go through runComm since it needs to
# happen for the -n flag to work properly).
. ${BUILD_DIR}/daq-service-project-map

# The deploy dir on the remote hosts
DEPLOY_DIR=jboss/server/iceboss0/deploy

# Special setup for merc "cluster".
if [ "${CLUSTER}" = "merc" ]; then
  DEPLOY_NODES=${NODES}

  # The deployment dir, assumes $ICEBOSS_HOME is defined
  DEPLOY_DIR=${ICEBOSS_HOME}/jboss/server/iceboss0/deploy
  if [ ! -d ${DEPLOY_DIR} ]; then
    echo "The deployment dir: ${DEPLOY_DIR}"
    echo "either doesn't exist or isn't a directory."
    echo "This path is built as follows: \${ICEBOSS_HOME}/jboss/server/iceboss0/deploy"
    exit 1
  fi

  # If running on cygwin, the fix the BUILD_DIR to DOS syntax
  if uname -s | grep -i cygwin > /dev/null 2>&1; then
    BUILD_DIR="`cygpath -m "${BUILD_DIR}"`"
  fi
fi

# A function for building all the .sar files
build_sars () {
  for sp_pair in ${SP_MAP}; do
    # Break apart the service and project names from the 'associative array' 
    sname=`echo $sp_pair | sed s/,.*//`  # The service name
    pname=`echo $sp_pair | sed s/.*,//`  # The project that builds that service

    # Only build services listed via the -r flag, if it was used at all.
    if [ -z "${CUST_SRVC}" -o "`echo ${CUST_SRVC} | grep ${sname}`" ]; then
      runComm "ant ${ANT_FLAGS} -DPROJECT=${pname} -DXML=${BUILD_DIR}/${sname}-service.xml ${SAR_TARGET}"
      runComm "mv ./lib/${pname}.sar ./lib/${sname}.sar"
    fi
  done
}

# A function to build all the .ear files.
build_ears () {
  for node in ${DEPLOY_NODES}; do
    runComm "ant ${ANT_FLAGS} -DEAR=daq-${node} -DEAR_XML=${BUILD_DIR}/daq-${node}-app.xml -DJBOSS_XML=${BUILD_DIR}/daq-${node}-jboss.xml ${EAR_TARGET}"
  done
}

push_ears () {
  for node in ${DEPLOY_NODES}; do
    # This little trick will make it so jboss doesn't try to deploy the
    # ear file before it has finished being copied there.
    if [ "${CLUSTER}" = "merc" ]; then
      runComm "cp ${WS_DIR}/lib/daq-${node}.ear ${DEPLOY_DIR}/.."
      runComm "mv ${DEPLOY_DIR}/../daq-${node}.ear ${DEPLOY_DIR}"
    else
      runComm "scp ${WS_DIR}/lib/daq-${node}.ear jboss@${node}:/tmp"
      runComm "ssh jboss@${node} \"mv /tmp/daq-${node}.ear ${DEPLOY_DIR}\""
    fi
  done
}

undeploy_ears () {
  # First undeploy all the .ears
  for node in ${DEPLOY_NODES}; do
    if [ "${CLUSTER}" = "merc" ]; then
      runComm "rm ${DEPLOY_DIR}/daq-${node}.ear"
    else
      runComm "ssh jboss@${node} \"rm ${DEPLOY_DIR}/daq-${node}.ear\""
    fi
  done

  runComm "sleep 5"

  # Then undeploy the jmx-consoles to release any references to
  # classes in the .ear file which have been undeployed
  for node in ${DEPLOY_NODES}; do
    if [ "${CLUSTER}" = "merc" ]; then
      runComm "mv ${DEPLOY_DIR}/jmx-console.war ${DEPLOY_DIR}/.."
    else
      runComm "ssh jboss@${node} \"mv ${DEPLOY_DIR}/jmx-console.war ${DEPLOY_DIR}/..\""
    fi
  done

  runComm "sleep 5"

  # Now put the jmx-consoles back
  for node in ${DEPLOY_NODES}; do
    if [ "${CLUSTER}" = "merc" ]; then
      runComm "mv ${DEPLOY_DIR}/../jmx-console.war ${DEPLOY_DIR}"
    else
      runComm "ssh jboss@${node} \"mv ${DEPLOY_DIR}/../jmx-console.war ${DEPLOY_DIR}\""
    fi
  done

}

do_command () {
  for node in ${DB_NODES} ${NODES}; do
    runComm "ssh jboss@${node} \"${COMMAND}\""
  done
}

# Now do all the real work
case ${ACTION} in
build)
  build_sars
  ;;
deploy)
  test "$COMPILE" && build_sars  # If we've complied clean, then build sars too
  build_ears
  push_ears
  ;;
undeploy)
  undeploy_ears
  ;;
command)
  do_command
  ;;
*)
  echo "Unknown ACTION: '${ACTION}'.  One of the: '-b' (build), '-d' (deploy) or '-u' (undeploy) flags must be used."
esac

# Pop back to the original dir, just in case this script was sourced
# rather than executed
runComm "cd ${START_DIR}"

# I know what you're thinking.  "Why would anyone write this script in
# sh?"  It's a good question.  My only responce is the typical
# software engineer's: it started out as something very simple and
# supposidly short-lived.  It did indeed start out simple and perhaps
# it will be some day be replaced - hope springs eternal.  But in true
# "death by a thousand paper cuts" form, it has grown to what you now
# see before you.
